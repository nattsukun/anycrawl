{
  "name": "HotelPlus Blog to SQLite Table",
  "nodes": [
    {
      "parameters": {},
      "id": "start-node",
      "name": "Start",
      "type": "n8n-nodes-base.start",
      "typeVersion": 1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "url": "https://www.hotelplus.asia/blog",
        "method": "GET",
        "options": {}
      },
      "id": "http-blog-list",
      "name": "Get Blog List Page",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "operation": "extractHtmlContent",
        "extractionValues": {
          "values": [
            {
              "key": "articleLinks",
              "cssSelector": "a[href*='/blog/']",
              "returnValue": "attribute",
              "attribute": "href",
              "returnArray": true
            }
          ]
        },
        "options": {}
      },
      "id": "html-extract-links",
      "name": "HTML - Extract Links",
      "type": "n8n-nodes-base.html",
      "typeVersion": 1,
      "position": [650, 300]
    },
    {
      "parameters": {
        "jsCode": "// Process and filter article URLs\nconst links = $input.item.json.articleLinks || [];\nconst uniqueUrls = new Set();\n\nlinks.forEach(link => {\n  if (link && link.includes('/blog/') && !link.includes('#')) {\n    const fullUrl = link.startsWith('http') ? link : `https://www.hotelplus.asia${link}`;\n    uniqueUrls.add(fullUrl);\n  }\n});\n\nconst urls = Array.from(uniqueUrls);\n\nreturn urls.map((url, index) => ({\n  json: {\n    url: url,\n    id: index + 1\n  }\n}));"
      },
      "id": "code-process-urls",
      "name": "Process URLs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 300]
    },
    {
      "parameters": {
        "batching": {
          "batch": {
            "batchSize": 1
          }
        }
      },
      "id": "split-in-batches",
      "name": "Split In Batches",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "url": "={{ $json.url }}",
        "method": "GET",
        "options": {
          "timeout": 30000
        }
      },
      "id": "http-get-article",
      "name": "Get Article Content",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "operation": "extractHtmlContent",
        "extractionValues": {
          "values": [
            {
              "key": "title",
              "cssSelector": "h1, .entry-title, .post-title, title",
              "returnValue": "text"
            },
            {
              "key": "content",
              "cssSelector": "article, .post-content, .entry-content, main",
              "returnValue": "text"
            },
            {
              "key": "metaDescription",
              "cssSelector": "meta[name='description']",
              "returnValue": "attribute",
              "attribute": "content"
            },
            {
              "key": "metaKeywords",
              "cssSelector": "meta[name='keywords']",
              "returnValue": "attribute",
              "attribute": "content"
            },
            {
              "key": "publishDate",
              "cssSelector": "time[datetime], .published-date, .post-date",
              "returnValue": "attribute",
              "attribute": "datetime"
            }
          ]
        },
        "options": {}
      },
      "id": "html-extract-content",
      "name": "Extract Article Metadata",
      "type": "n8n-nodes-base.html",
      "typeVersion": 1,
      "position": [1450, 300]
    },
    {
      "parameters": {
        "jsCode": "// Map scraped data to metadata format\nconst item = $input.item.json;\nconst prevNodeData = $node[\"Split In Batches\"].json;\nconst url = prevNodeData.url;\nconst id = prevNodeData.id;\n\n// Extract and clean data\nconst title = (item.title || 'Untitled').trim();\nconst content = (item.content || '').trim();\nconst description = (item.metaDescription || content.substring(0, 200)).trim();\nconst keywords = (item.metaKeywords || title.substring(0, 50)).trim();\nconst publishDate = item.publishDate || new Date().toISOString().split('T')[0];\n\n// Detect language\nconst thaiRegex = /[\\u0E00-\\u0E7F]/;\nconst language = thaiRegex.test(title + description) ? 'TH' : 'EN';\n\n// Detect location\nconst locationMap = {\n  'เชียงใหม่': 'เชียงใหม่',\n  'chiangmai': 'เชียงใหม่',\n  'chiang mai': 'เชียงใหม่',\n  'ภูเก็ต': 'ภูเก็ต',\n  'phuket': 'ภูเก็ต',\n  'กรุงเทพ': 'กรุงเทพ',\n  'bangkok': 'กรุงเทพ',\n  'พัทยา': 'พัทยา',\n  'pattaya': 'พัทยา',\n  'เกาะสมุย': 'เกาะสมุย',\n  'samui': 'เกาะสมุย'\n};\n\nlet location = '';\nconst searchText = (title + content + url).toLowerCase();\nfor (const [key, value] of Object.entries(locationMap)) {\n  if (searchText.includes(key.toLowerCase())) {\n    location = value;\n    break;\n  }\n}\n\n// Determine type and category\nlet type = 'keyword';\nlet category = 'โรงแรม';\n\nif (title.includes('รีวิว') || title.toLowerCase().includes('review')) {\n  type = 'review';\n  category = 'รีวิว';\n} else if (title.includes('FAQ') || title.includes('คำถาม')) {\n  type = 'faq';\n  category = 'ความรู้ทั่วไป';\n} else if (title.includes('คู่มือ') || title.toLowerCase().includes('guide')) {\n  type = 'guide';\n  category = 'กลยุทธ์';\n} else if (title.includes('SEO') || title.includes('GEO')) {\n  category = 'กลยุทธ์';\n}\n\n// Detect topic\nconst topic = location || (title.includes('SEO') ? 'กลยุทธ์' : 'ทั่วไป');\n\nreturn {\n  json: {\n    id: id,\n    type: type,\n    topic: topic,\n    keyword: keywords,\n    description: description,\n    reference_id: `blog${id}_${new Date().getFullYear()}`,\n    url: url,\n    category: category,\n    location: location,\n    date: publishDate,\n    language: language,\n    search_volume: '',\n    competition: '',\n    ranking: '',\n    notes: `Scraped from hotelplus.asia on ${new Date().toISOString().split('T')[0]}`\n  }\n};"
      },
      "id": "code-map-metadata",
      "name": "Map to Metadata Format",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1650, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT OR REPLACE INTO metadata (id, type, topic, keyword, description, reference_id, url, category, location, date, language, search_volume, competition, ranking, notes) VALUES ({{ $json.id }}, '{{ $json.type }}', '{{ $json.topic }}', '{{ $json.keyword }}', '{{ $json.description }}', '{{ $json.reference_id }}', '{{ $json.url }}', '{{ $json.category }}', '{{ $json.location }}', '{{ $json.date }}', '{{ $json.language }}', '{{ $json.search_volume }}', '{{ $json.competition }}', '{{ $json.ranking }}', '{{ $json.notes }}');",
        "options": {}
      },
      "id": "insert-to-sqlite",
      "name": "Insert to SQLite",
      "type": "n8n-nodes-base.sqlite",
      "typeVersion": 1,
      "position": [1850, 300],
      "credentials": {
        "sqlite": {
          "id": "1",
          "name": "SQLite account"
        }
      }
    },
    {
      "parameters": {},
      "id": "loop-back",
      "name": "Loop Back",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [2050, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "CREATE TABLE IF NOT EXISTS metadata (\n  id INTEGER PRIMARY KEY,\n  type TEXT,\n  topic TEXT,\n  keyword TEXT,\n  description TEXT,\n  reference_id TEXT,\n  url TEXT,\n  category TEXT,\n  location TEXT,\n  date TEXT,\n  language TEXT,\n  search_volume TEXT,\n  competition TEXT,\n  ranking TEXT,\n  notes TEXT,\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);",
        "options": {}
      },
      "id": "create-table-sqlite",
      "name": "Create Table (First Run)",
      "type": "n8n-nodes-base.sqlite",
      "typeVersion": 1,
      "position": [850, 500],
      "credentials": {
        "sqlite": {
          "id": "1",
          "name": "SQLite account"
        }
      }
    },
    {
      "parameters": {
        "operation": "aggregateItems",
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "id": "aggregate-all",
      "name": "Aggregate All for CSV",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [1050, 500]
    },
    {
      "parameters": {
        "operation": "formatData",
        "format": "csv",
        "options": {
          "fileName": "hotelplus_metadata_{{ $now.format('yyyyMMdd_HHmmss') }}.csv",
          "headerRow": true,
          "delimiter": ","
        }
      },
      "id": "convert-csv",
      "name": "Convert to CSV (Backup)",
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1,
      "position": [1250, 500]
    },
    {
      "parameters": {
        "filePath": "C:\\Users\\NMuan\\Downloads\\hotelplus\\hotelplus_metadata_{{ $now.format('yyyyMMdd_HHmmss') }}.csv",
        "options": {}
      },
      "id": "write-csv",
      "name": "Write CSV File (Backup)",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [1450, 500]
    }
  ],
  "connections": {
    "Start": {
      "main": [
        [{ "node": "Get Blog List Page", "type": "main", "index": 0 }],
        [{ "node": "Create Table (First Run)", "type": "main", "index": 0 }]
      ]
    },
    "Get Blog List Page": {
      "main": [[{ "node": "HTML - Extract Links", "type": "main", "index": 0 }]]
    },
    "HTML - Extract Links": {
      "main": [[{ "node": "Process URLs", "type": "main", "index": 0 }]]
    },
    "Process URLs": {
      "main": [[{ "node": "Split In Batches", "type": "main", "index": 0 }]]
    },
    "Split In Batches": {
      "main": [
        [{ "node": "Get Article Content", "type": "main", "index": 0 }],
        [{ "node": "Aggregate All for CSV", "type": "main", "index": 0 }]
      ]
    },
    "Get Article Content": {
      "main": [[{ "node": "Extract Article Metadata", "type": "main", "index": 0 }]]
    },
    "Extract Article Metadata": {
      "main": [[{ "node": "Map to Metadata Format", "type": "main", "index": 0 }]]
    },
    "Map to Metadata Format": {
      "main": [[{ "node": "Insert to SQLite", "type": "main", "index": 0 }]]
    },
    "Insert to SQLite": {
      "main": [[{ "node": "Loop Back", "type": "main", "index": 0 }]]
    },
    "Loop Back": {
      "main": [[{ "node": "Split In Batches", "type": "main", "index": 0 }]]
    },
    "Aggregate All for CSV": {
      "main": [[{ "node": "Convert to CSV (Backup)", "type": "main", "index": 0 }]]
    },
    "Convert to CSV (Backup)": {
      "main": [[{ "node": "Write CSV File (Backup)", "type": "main", "index": 0 }]]
    }
  },
  "pinData": {}
}
